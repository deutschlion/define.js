{"name":"DefineJS","tagline":"A JavaScript module loader, an implementation of AMD (Asynchronous Module Definition).","body":"##DefineJS v0.2.2 Released\r\nThe new version with a whole bunch of examples and couple of new features, is ready to use. DefineJS now offers `Promissed Modules` and `use()` syntax.\r\n\r\n##Promised Modules\r\nUsing the same AMD module style you can have privileged promise based modules. \r\nAll you need to do is just returning a promise in your modules, to make them promised modules. \r\nTo see how it works, just check out the `simple-promised-module example` in the examples folder.\r\n\r\nIn this example we have a promised module named: promisedModule.js \r\nwhich is responsible to wait for a specific global variable, and serves it as the module's promised value.\r\n```\r\n//promisedModule.js\r\ndefine([ /*'dependency'*/ ], function ( /*dependency*/ ) {\r\n\r\n  return new Promise(function (fulfill, reject) {\r\n    //Here you expect to have a global variable named: myApp after 2 seconds\r\n    //otherwise your module definition gets rejected\r\n\r\n    setTimeout(function () {\r\n      if (window.myApp !== undefined) {\r\n\r\n        //fulfill when succeeded and pass the fulfillment value\r\n        fulfill({\r\n          app: window.myApp,\r\n          log: 'This is just a sample promised object to serve as a promised module!'\r\n        });\r\n\r\n      } else {\r\n\r\n        //reject in case of error or unsuccessful operations\r\n        reject(new Error('No global myApp object found!!'));\r\n      }\r\n\r\n    }, 2000);\r\n  });\r\n\r\n});\r\n```\r\nNow you could easily require it, or add it as a dependency. What will happen is, it waits for your promise to get resolved then you will have the promised module object.\r\n```\r\n//main.js\r\nrequire(['promisedModule'],\r\n  function(promisedModule){\r\n    console.log(promisedModule.log);//=>This is just a sample promised object!\r\n    console.log(promisedModule.app);\r\n  });\r\n```\r\n\r\n###Note:\r\nwe are still discussing about the proper way of handling the rejected state of a promised module. Any feedback or proposal is really appreciated.\r\n\r\n##use() vs require()\r\nYou can also have the same modules flow using a new offered syntax by DefineJS:\r\n```\r\nuse(['dependency1', 'dependency2'])\r\n  .then(function(dependency1, dependency2){\r\n    //...\r\n    return dependency1.util;\r\n  })\r\n  .then(function(util){\r\n    //...\r\n    //use util object if it has any useful functionality\r\n    return util.map([/*...*/]);\r\n  })\r\n  .catch(function(e){\r\n    //in case of having a rejected promised module or any async error\r\n    console.error(e);\r\n  });\r\n```\r\n\r\n----------\r\n\r\n##DefineJS\r\n\r\nDefineJS is a lightweight implementation of [AMD](https://github.com/amdjs/amdjs-api) module format.\r\n\r\n> The Asynchronous Module Definition (AMD) API specifies a mechanism for defining modules such that the module and its dependencies can be asynchronously loaded.\r\n\r\nNo need to discuss the definition further, it is accurately enough to see the starting point clearly.\r\n\r\nIt is all about writing clean, testable, understandable and maintainable code. There might be more descriptive adjectives here but what we actually mean when we discuss these points, to a large extent, could be summarized in one single principle which is writing modular code.\r\n\r\nAs an aged JavaScript developer I could remember debates and sometimes actual wars, around this very topic. When I hear the other team members, mostly from a more structural programming language, whispering:\r\n\r\n> **WTF?** What the hell is he talking about! He asks us to do the impossible: writing clean code in JavaScript. **Has anyone seen it, for real?**\r\n\r\nTo be honest the last time I heard someone saying that was just two weeks ago, of course someone with a Shell/Ruby/Python background and not a JavaScript developer, but it was still a lot to me.\r\n\r\nThese days, as JavaScript developers we can implement almost anything, a [ROBOT](http://cylonjs.com/) or an end to end enterprise solution with a friendly and fun [Javascript Fullstack](http://mean.io/).\r\nIt means that JavaScript scales up as it finds more  implications in different areas. And as it goes on, we necessarily need to have a general mechanism with a shared understanding around it, a general mechanism for defining independent and interchangeable pieces which can work together perfectly. This is what modular programming, gives us:\r\n\r\n\r\n>**Modular programming** is a software design technique that emphasizes *separating the functionality of a program into independent, interchangeable modules*, such that each contains everything necessary to execute only one aspect of the desired functionality. Conceptually, modules represent a **separation of concerns**, and improve **maintainability** by enforcing **logical boundaries** between components.\r\n\r\n## Writing Modular JavaScript\r\nThis mechanism has already been thought out and we now have a couple of great modular coding formats, and to me these three are the most exciting ones:\r\n\r\n* [**AMD**](https://github.com/amdjs/amdjs-api/blob/master/AMD.md): The Asynchronous Module Definition (AMD) API specifies a mechanism for defining modules such that the module and its dependencies can be asynchronously loaded. This is particularly well suited for the browser environment where synchronous loading of modules incurs performance, usability, debugging, and cross-domain access problems.\r\n* [**CommonJS**](http://wiki.commonjs.org/wiki/CommonJS): Unfortunately, it was defined without giving browsers equal footing to other JavaScript environments **[....](http://requirejs.org/docs/commonjs.html)**\r\n* [**ES6 Modules**](http://calculist.org/blog/2012/03/29/synchronous-module-loading-in-es6/): What we are going to have in the next version of JavaScript, **Harmony**.\r\n\r\nThese three ways each seems to have bunch of pros and cons, but more importantly each has its own syntax format, which makes it difficult to use them interchangeably.\r\n\r\n**DefineJS** as a module loader has chosen **AMD** to provide as its underlying module format.\r\n\r\n## Notes\r\nThere are couple of important points which I have faced with during the implementation of this module loader. All of them bring up one simple question:\r\n\r\n> As library authors are we better off implementing everything needed, the best and the worst practices all mixed together?\r\n\r\n**OR**\r\n\r\n> Some might say, a great library is the one which prevents its developers from getting drowned in a bad code.\r\n\r\nSince a module loader needs to be compatible even with possible uses of what is already known as a bad practice, my answer when implementing **DefineJS** was **YES** to the first question.\r\n\r\nFor instance, when working with an AMD module loader, you can explicitly name modules yourself, but it makes the modules less portable and if you move the file to another directory you will need to change the name. **BUT** it still is there and you can use it to define named modules.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}